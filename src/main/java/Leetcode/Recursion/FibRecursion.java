package Leetcode.Recursion;

import org.junit.Assert;
import org.junit.Test;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * @Description TODO
 * @Author xiamoxin
 * @Date 2020/9/9 10:16
 **/
public class FibRecursion {

    private static final FibRecursion instance = new FibRecursion();

    Set<Integer> swingSet = new HashSet<>();

    /**
     *@描述  数组实现 f(n)的存储，最后返回f(n) 空间复杂度O(N) 时间复杂度 O(N)
     *@参数 [n]
     *@返回值 int
     *@创建人 xiamaoxin
     *@创建时间 2020/9/9
     */
    public static int fib(int n) {
        if(n == 0){
            return 0;
        }
        int [] arr = new int[n + 1];
        arr[0] = 0;
        arr[1] = 1;
        for(int i = 2;i <= n; i++){
          arr[i] = arr[i - 1] + arr[i - 2];
          arr[i] %= 1000000007;
        }
        return arr[n];
    }

    /**
     * @Description:
     * 泰波那契序列 Tn 定义如下： 
     *
     * T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
     *
     * 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。
     *
     *  
     *
     * 示例 1：
     *
     * 输入：n = 4
     * 输出：4
     * 解释：
     * T_3 = 0 + 1 + 1 = 2
     * T_4 = 1 + 1 + 2 = 4
     *
     * solution：follow the question ,and answer the question quickly
     * @Date: 2020/12/30 10:55
     */
    public int tribonacci(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 1;
        }
        int[] arr = new int[n + 1];
        arr[0] = 0;
        arr[1] = 1;
        arr[2] = 1;
        for (int i = 3; i < n + 1; i++) {
           arr[i] = arr[i - 3] + arr[i - 2] + arr[i - 1];
        }
        return arr[n];
    }

    /**
     * @Description:
     * 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
     *
     * 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
     *
     * 示例 1：
     *
     * 输入：n = 2
     * 输出：2
     * 示例 2：
     *
     * 输入：n = 7
     * 输出：21
     *
     * solution:
     * @Date: 2020/12/30 11:25
     */
    public int numWays(int n) {
        if(n==0){
            return 1;
        }
        int [] arr = new int[n+1];
        arr[0] = 1;
        arr[1] = 1;
        for(int i=2;i<=n;i++){
            arr[i] = arr[i-1]+arr[i-2];
            arr[i] %= 1000000007;
        }
        return arr[n];
    }
    //这两个小世界本尊开重了，虫小世界消失 违者朱砂  此人十岁 好大的口气   居然要讲  傻了亚航点的准主
    //如今炼化了就有磨练 他要一个人驱逐所有人   武皇不出 没人能来和得了你混蛋道士  奈何得了  建木
    // 少主，我们该如何做   打扫战场的事情就交给炎帝了  正如凌风所想的那样  论心境 谁能和他比   便将小世界清理干净
    //无论所抢  不滚酒混砂  福清慕青  一出事西黄的的小世界  魔气滔天    羲皇
    //要拿出笑话世界-- 新的皇宫  小风 你确定没有问题  等到几天后 扬州城冲刺时 皇宫出口之地  同事已发针封闭
    //  云海中那边  我希望云海中那边嗯国强哼起来     已非昔日云海   我会掌控好的  林海笑着说道
    // 谢谢富强  齐家 天龙圣宝  手握阜成 叫他就哟磨练    好事要想整个小世界包裹在里面   无数人组瞅着
    // 中人也赶路不敢言   而且还有更让人意外的  太坑了 看来我们该回去了   许多人站在小世界的外围
    //升值小世界的上空都缭绕着一层雾气  用阵法将整个小世界包裹在里面  此时 短信也意外在林枫的身边
    //都不需要改造了 以后你便在这里面住   将柳菲也拉上前来 傻丫头外面的世界并不怎么太平  况且林枫也是为了他们着想
    //此时 已到生硬传来  这混蛋交货 又开始腹黑了  对着炎帝说到 凡是总的有例外  严地笑道 况且有本地这干爹在 害怕天赋跟不上去嘛
    //本地难道还会亏待你孩子不行  好了 眼底可是大地强者 如今林枫的一家人倒是和炎帝比较熟悉了
    //所有的一切都无法阻挡  冲出了这片天地  耗时田贝那一抹 舍得他眼睛都微微闭上 捅破了天 他一定很久没有真阳震撼了
    //回来  下空已到和声古滚滚而来  回到那滚滚的魔物中  为何连天都能捅破  方才那一抹光速是从哪里出来的
    //不需要我告诉你 你很快就能接触到了 三生经 林枫眼眸中 他拿到了  若是修的三生经  你应该知道一些吧 你感觉到了什么
    //严地反问  生命波动 眼底慕闪烁   经盯着林枫 还有强生的灵魂波动  羲皇未到二十 真的死了吗
    //你别问那么多  得到了就哟磨炼，其他归你 等你看完了，可以将三生经借我 我给你参考下
    //顿时，无数的符文开始闪烁了起来  师父过了很久 林枫的申联才冲那一页经书中顿悟了过来
    //他此刻才明白 三生  许多人都理解错了三生经   本尊 佛身 魔身 错了，原来所有人都理解错了 哪里有什么佛魔功法，恐怕有就大路
    //新业 悦心 身体微微一颤  他的身体好似 魏帝 瞬间有一道身影出现在了 ，小家伙 是不是需要本帝喂你参考 参考
    //射出一道锋锐之光  三生经 好一个三生经 单生意 一声儿 三生万物 魏帝，准备修炼嘛 我还是留下时间玩火 ，更适合我写
    //这么强大的帝境，我怎么可能不修炼  你要修炼三生经 帝境之中有太多可取之处，三生经 是一条证道之路
    //你和柳非姐都还没有  用手托着她的下巴  不会被你手持弓箭追杀吧   这家伙，以前是的时间还接着呢 一切自会水到渠成
    //林枫怎能舍得丢弃小雅 尤其是在九幽魔帝锁芯，如今一切都已过去 就有抹去，以及时万分幸运了 眼底这家伙
    //如今的炎帝 走出雪月 他还是干引导式的面貌出现 这边是找事了 更何况他坑的是八位武皇 不容易塔克的好哈的或者才行
    //直到小世界已经成为少主的阆中植物  龙山帝国，我有些事情需要处理  没有云飞扬的消息，既然如此，他一定要走一趟了工商帝国的
    //没有凶兽穷奇的凶戾之气  但队友拥有 并没有用太久的时间1 炎帝，辖区 我请你喝几杯 而在他们深浅不远处，了工商帝国第一酒楼
    //一个个用金茶蛋额目光看着那一人一摇  不过似乎诶呦那种气势 肥胖了些 那群年轻的白衣身影呢 人群目光将于 僵硬不知道他与请萌新相比如何
    //滚  病怎么华您其他人  这家伙要倒霉了  请萌新的师妹   这么久不见，你就折磨讨厌我了 白衣长袍 产懒得笑容 都出了积分西戎语塞的笑容
    //无法说出  我身上没有原始，不介意请我和基本把  隋杰将原始放入凹槽之中，你瘦了不少而且修为也没什么张静 舒服，李峰笑着说道


    //在梅边自己的理由 走在春夏秋冬  慕青已经白头  我也不再年幼  我发我早已经长大  我发现我早已不说谎话
    //冲不用质疑  所以我努力的跑 不用问我的来路 贫民窟的艺术家爱
    //菜鸟呢  至少我还有梦 也为内温柔感动 就在我的行李米娜 只要我还有梦 就会看到彩虹 在我的天空
    //调调to the png  找到属于我的爱 哈一页  咋丽萍的起点 就在我的心里面  哈还诶  在武警的黑夜 所有都快要毁灭  我还有梦 为你而岗东
    //我还有鞥呢 我看到彩虹 在我的天空 也要  整一套这里 看我快乐地说爱丽路亚 我发是要做老大 难道我就是老大 老丢十七厂 老大就是风流倜傥
    //就这个样子 看我方式的不像个样子 问你配不配 做大哥的滋味美不美
    //就当做我太麻烦 不定让自己受伤我告诉我自己  感情就是这样 怎么一不小心太疯狂  有开闸UGN就有结尾 也许是一个机会
    //搞毛呢 生鲜这选民窝里 说不上爱别说谎 久一点喜欢 说不上恨别纠缠1别装作感叹  就当我太麻烦不停让自己受伤我告诉我自己 感情就是这样
    //怎么一不小心太疯狂 不敢你主流 或者你底下  我们是hipop
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    //
    /**
     * @Description:
     *  你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。
     *
     * 返回的长度需要从小到大排列。
     *
     * 示例 1
     *
     * 输入：
     * shorter = 1
     * longer = 2
     * k = 3
     * 输出： [3,4,5,6]
     * 解释：
     * 可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。
     *
     * solution: 穷举法，列出所有可能 2的k次方 总数，然后去重
     * 递归和记忆法都会超时，举例  k非常大的情况 只有是用数学归纳法
     * k块跳板，一共k+1中情况  1.all is shorter 2.all is longer 3.一次减少一个shorter，增加一个longer k - 1 一共 k + 1
     * @Date: 2021/1/4 14:12
     */
    public int[] divingBoard(int shorter, int longer, int k) {
        if (k == 0) {
            return new int[0];
        }
        if (shorter == longer) {
            return new int[]{shorter * k};
        }
        int[] res = new int[k + 1];
        for (int i = 0; i < res.length; i++) {
            res[i] = shorter * (k - i) + longer * i;
        }
        return res;
    }


    /**
     * @Description:
     *  在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
     * (1) 每次只能移动一个盘子;
     * (2) 盘子只能从柱子顶端滑出移到下一根柱子;
     * (3) 盘子只能叠在比它大的盘子上。
     *
     * 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
     *
     * 你需要原地修改栈。
     *
     * 示例1:
     *
     *  输入：A = [2, 1, 0], B = [], C = []
     *  输出：C = [2, 1, 0]
     * 示例2:
     *
     *  输入：A = [1, 0], B = [], C = []
     *  输出：C = [1, 0]
     * 提示:
     *
     * A中盘子的数目不大于14个
     *
     * solution:  官方解答，采用数学归纳法  有点绕，只能明白大概思路 无法自我解答
     * O(N) O(N)
     * @Date: 2021/1/4 15:00
     */
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        movePlate(A.size(),A,B,C);
    }

    private void movePlate(int num, List<Integer> original, List<Integer> auxiliary, List<Integer> target) {
        if (num == 0) {
            // 只有一个盘子  直接 target.add original.remove
            target.add(original.remove(original.size() - 1));
            return;
        }
        movePlate(num - 1,original,target,auxiliary);
        target.add(original.remove(original.size() - 1));
        movePlate(num - 1,auxiliary,original,target);
    }





    @Test
   public void testTribonacci() {
        int[] arr = new int[] {3,4,5,6};
        Assert.assertEquals(arr,instance.divingBoard(1,2,3));
   }
}
